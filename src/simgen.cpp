// MIT License

// Copyright (c) 2025 Meng Chengzhen, in Shandong University

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#include "simgen.h"

#include <chrono>
#include <iomanip>
#include <sstream>
#include <string>
#include <cctype>

namespace simgen {

string genCurrentTimeString() {
    std::chrono::system_clock::time_point now = std::chrono::system_clock::now();
    std::time_t tt = std::chrono::system_clock::to_time_t(now);
    std::tm* ptm = std::localtime(&tt);
    std::ostringstream oss;
    oss << std::put_time(ptm, "%Y-%m-%d %H:%M:%S");
    return oss.str();
}

vector<string> genHeaderPrelude() {
    static const vector<string> code_header_prelude = {
        "// This header file is generated by VulSim SimGen tool.\n",
        "// Do not modify this file directly.\n",
    };
    vector<string> out = code_header_prelude;
    out.push_back("// Generated on: " + genCurrentTimeString() + "\n");
    out.push_back("\n");
    out.push_back("#pragma once\n");
    out.push_back("\n");
    return out;
}

string replaceLog2CeilChar(const ConfigValue &v) {
    // replace @ with log2ceil function call
    if (v.find('@') == string::npos) {
        return v; // no '@' found, return original
    }
    string out;
    size_t n = v.size();
    size_t i = 0;
    while (i < n) {
        if (v[i] != '@') {
            out.push_back(v[i]);
            ++i;
            continue;
        }

        // found '@'
        size_t k = i + 1;
        // skip spaces immediately after '@'
        while (k < n && std::isspace(static_cast<unsigned char>(v[k]))) ++k;

        // if nothing follows, replace with an empty-call
        if (k >= n) {
            out += "log2ceil()";
            i = n;
            break;
        }

        // if next is '(', reuse it as function call bracket
        if (v[k] == '(') {
            out += "log2ceil"; // keep the original '(' in next iterations
            i = k; // continue processing from the '('
            continue;
        }

        // identifier: [A-Za-z_][A-Za-z0-9_]*
        if (std::isalpha(static_cast<unsigned char>(v[k])) || v[k] == '_') {
            size_t t = k + 1;
            while (t < n && (std::isalnum(static_cast<unsigned char>(v[t])) || v[t] == '_')) ++t;
            out += "log2ceil(" + v.substr(k, t - k) + ")";
            i = t;
            continue;
        }

        // number literal: decimal or hex (0x...)
        if (std::isdigit(static_cast<unsigned char>(v[k]))) {
            size_t t = k;
            if (t + 1 < n && v[t] == '0' && (v[t+1] == 'x' || v[t+1] == 'X')) {
                t += 2;
                while (t < n && std::isxdigit(static_cast<unsigned char>(v[t]))) ++t;
            } else {
                while (t < n && std::isdigit(static_cast<unsigned char>(v[t]))) ++t;
            }
            out += "log2ceil(" + v.substr(k, t - k) + ")";
            i = t;
            continue;
        }

        // fallback: just insert function name and continue after spaces
        out += "log2ceil";
        i = k;
    }

    return out;
}

vector<string> genCppHeaderPrelude() {
    static const vector<string> code_cpp_header_prelude = {
        "// This source file is generated by VulSim SimGen tool.\n",
        "// Do not modify this file directly.\n",
    };
    vector<string> out = code_cpp_header_prelude;
    out.push_back("// Generated on: " + genCurrentTimeString() + "\n");
    out.push_back("\n");
    return out;
}

ErrorMsg genConfigHeaderCode(const VulConfigLib &config_lib, vector<string> &out_lines) {
    out_lines = genHeaderPrelude();

    out_lines.push_back("#include \"common.h\"\n");
    out_lines.push_back("\n");
    out_lines.push_back("// Configuration Items\n");
    out_lines.push_back("\n");

    ErrorMsg err;
    vector<ConfigName> sorted_items;
    err = config_lib.getAllConfigItemsTopoSort(sorted_items);
    if (!err.empty()) {
        return err;
    }

    for (const auto &item_name : sorted_items) {
        VulConfigItem item;
        err = config_lib.getConfigItem(item_name, item);
        if (!err.empty()) {
            return err;
        }
        // generate comment per line
        Comment &cmt = item.comment;
        size_t pos = 0;
        while (true) {
            size_t next_pos = cmt.find('\n', pos);
            if (next_pos == string::npos) break;
            string line = cmt.substr(pos, next_pos - pos);
            out_lines.push_back("// " + line + "\n");
            pos = next_pos + 1;
        }
        if (pos < cmt.size()) {
            string line = cmt.substr(pos);
            out_lines.push_back("// " + line + "\n");
        }
        // generate code line
        string line;
        line += "constexpr int64_t ";
        line += item.name;
        line += " = ";
        line += replaceLog2CeilChar(item.value);
        line += ";\n";
        out_lines.push_back(line);
        out_lines.push_back("\n");
    }

    return string();
}


/**
 * @brief Generate bundle.h C++ header code for bundle definitions.
 * @param bundle_lib The VulBundleLib instance containing bundle definitions.
 * @param out_lines Output vector of strings to hold the generated header code lines. With \\n in each line.
 * @return An ErrorMsg indicating failure, empty if success.
 */
ErrorMsg genBundleHeaderCode(const VulBundleLib &bundle_lib, vector<string> &out_lines) {
    out_lines = genHeaderPrelude();

    out_lines.push_back("#include \"common.h\"\n");
    out_lines.push_back("#include \"config.h\"\n");
    out_lines.push_back("\n");
    out_lines.push_back("// Bundle Definitions\n");
    out_lines.push_back("\n");

    ErrorMsg err;
    vector<BundleName> sorted_bundles;
    err = bundle_lib.getAllBundlesTopoSort(sorted_bundles);
    if (!err.empty()) {
        return err;
    }

    for (const auto &bundle_name : sorted_bundles) {
        VulBundleItem item;
        unordered_set<BundleTag> tags;
        err = bundle_lib.getBundleDefinition(bundle_name, item, tags);
        if (!err.empty()) {
            return err;
        }
        // surround with ifndef guard when tagged
        bool is_not_default_tag = !(tags.size() == 1 && tags.count(bundle_lib.DefaultTag) == 1);
        string def_gaurd = "_BUNDLE_" + bundle_name + "_DEFINED_";
        if (is_not_default_tag) {
            for (const auto &tag : tags) {
                out_lines.push_back("#ifndef " + def_gaurd + "\n");
                out_lines.push_back("#define " + def_gaurd + " 1\n");
            }
        }

        // generate comment per line
        Comment &cmt = item.comment;
        size_t pos = 0;
        while (true) {
            size_t next_pos = cmt.find('\n', pos);
            if (next_pos == string::npos) break;
            string line = cmt.substr(pos, next_pos - pos);
            out_lines.push_back("// " + line + "\n");
            pos = next_pos + 1;
        }
        if (pos < cmt.size()) {
            string line = cmt.substr(pos);
            out_lines.push_back("// " + line + "\n");
        }

        // generate code line
        // for alias bundle, generate a typedef
        if (item.is_alias) {
            string alias_target = "";
            if (!item.basic_members.empty()) {
                alias_target = item.basic_members[0].type;
            } else if (!item.uint_members.empty()) {
                alias_target = "UInt<" + replaceLog2CeilChar(item.uint_members[0].length) + ">";
            } else if (!item.array_members.empty()) {
                for (const auto &dim : item.array_members[0].dims) {
                    alias_target += "std::array<";
                }
                alias_target += item.array_members[0].type;
                for (uint32_t i = item.array_members[0].dims.size(); i > 0; i--) {
                    alias_target += ", " + replaceLog2CeilChar(item.array_members[0].dims[i-1]) + ">";
                }
            } else if (!item.uint_array_members.empty()) {
                for (const auto &dim : item.uint_array_members[0].dims) {
                    alias_target += "std::array<";
                }
                alias_target += "UInt<" + replaceLog2CeilChar(item.uint_array_members[0].length) + ">";
                for (uint32_t i = item.uint_array_members[0].dims.size(); i > 0; i--) {
                    alias_target += ", " + replaceLog2CeilChar(item.uint_array_members[0].dims[i-1]) + ">";
                }
            }
            if (alias_target.empty()) {
                return EStr(EItemBundAliasInvalid, "Alias bundle '" + bundle_name + "' has no valid member for alias target");
            }
            out_lines.push_back("typedef " + alias_target + " " + bundle_name + ";\n");
        }
        // for enum bundle, generate enum class
        else if (!item.enum_members.empty()) {
            out_lines.push_back("enum class " + bundle_name + " {\n");
            for (const auto &em : item.enum_members) {
                string member_str = "    " + em.name;
                if (!em.value.empty()) {
                    member_str += " = " + replaceLog2CeilChar(em.value);
                }
                member_str += ",";
                if (!em.comment.empty()) {
                    member_str += " // " + em.comment;
                }
                out_lines.push_back(member_str + "\n");
            }
            out_lines.push_back("};\n");
        }
        // otherwise, generate typedef struct
        else {
            out_lines.push_back("typedef struct __" + bundle_name + "__ {\n");
            for (const auto &bm : item.basic_members) {
                string member_str = "    " + bm.type + " " + bm.name;
                if (!bm.value.empty() && isBasicVulType(bm.type)) {
                    member_str += " = " + replaceLog2CeilChar(bm.value);
                }
                member_str += ";";
                if (!bm.comment.empty()) {
                    member_str += " // " + bm.comment;
                }
                out_lines.push_back(member_str + "\n");
            }
            for (const auto &um : item.uint_members) {
                string member_str = "    UInt<" + replaceLog2CeilChar(um.length) + "> " + um.name;
                if (!um.value.empty()) {
                    member_str += " = " + replaceLog2CeilChar(um.value);
                }
                member_str += ";";
                if (!um.comment.empty()) {
                    member_str += " // " + um.comment;
                }
                out_lines.push_back(member_str + "\n");
            }
            for (const auto &am : item.array_members) {
                string type_str = "";
                for (const auto &dim : am.dims) {
                    type_str += "std::array<";
                }
                type_str += am.type;
                for (uint32_t i = am.dims.size(); i > 0; i--) {
                    type_str += ", " + replaceLog2CeilChar(am.dims[i-1]) + ">";
                }
                string member_str = "    " + type_str + " " + am.name + "{};";
                if (!am.comment.empty()) {
                    member_str += " // " + am.comment;
                }
                out_lines.push_back(member_str + "\n");
            }
            for (const auto &uam : item.uint_array_members) {
                string type_str = "";
                for (const auto &dim : uam.dims) {
                    type_str += "std::array<";
                }
                type_str += "UInt<" + replaceLog2CeilChar(uam.length) + ">";
                for (uint32_t i = uam.dims.size(); i > 0; i--) {
                    type_str += ", " + replaceLog2CeilChar(uam.dims[i-1]) + ">";
                }
                string member_str = "    " + type_str + " " + uam.name + "{};";
                if (!uam.comment.empty()) {
                    member_str += " // " + uam.comment;
                }
                out_lines.push_back(member_str + "\n");
            }
            out_lines.push_back("} " + bundle_name + ";\n");
        }

        if (is_not_default_tag) {
            out_lines.push_back("#endif // " + def_gaurd + "\n");
        }
        out_lines.push_back("\n");
    }

    return string();
}



} // namespace simgen

