// MIT License

// Copyright (c) 2025 Meng Chengzhen, in Shandong University

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#include "simgen.h"
#include "toposort.hpp"

#include <chrono>
#include <iomanip>
#include <sstream>
#include <string>
#include <cctype>

namespace simgen {

const string CodeTab = "    ";

const string Log2CeilFunctionName = "log2ceil";
const string TickFunctionName = "on_current_tick";
const string ApplyTickFunctionName = "apply_next_tick";

const string UIntClassName = "UInt";
const string StorageNextClassName = "StorageNext";
const string StorageNextArrayClassName = "StorageNextArray";
const string PipeClassName = "Pipe";


enum class PipeImplType {
    Invalid,
    SimpleNoHandshakeNoBuffer,
    SimpleValidNoBuffer,
    SimpleHandshakeNoBuffer,
    SimpleHandshakeBuffer,
    MultiPortHandshakeBuffer,
};

inline PipeImplType determinePipeImplType(uint64_t input, uint64_t output, uint64_t buffer,
                                         bool has_handshake, bool has_valid) {
    if (has_handshake) {
        if (buffer > 0) {
            if (input > 1 && output > 1) {
                return PipeImplType::MultiPortHandshakeBuffer;
            } else {
                return PipeImplType::SimpleHandshakeBuffer;
            }
        } else {
            if (input > 1 && output > 1) {
                return PipeImplType::Invalid;
            } else {
                return PipeImplType::SimpleHandshakeNoBuffer;
            }
        }
    } else {
        if (input > 1 && output > 1) {
            return PipeImplType::Invalid;
        } else if (has_valid) {
            return PipeImplType::SimpleValidNoBuffer;
        } else {
            return PipeImplType::SimpleNoHandshakeNoBuffer;
        }
    }
}


string _genPipeClassName(uint64_t input, uint64_t output, uint64_t buffer,
                                         bool has_handshake, bool has_valid) {
    PipeImplType type = determinePipeImplType(input, output, buffer, has_handshake, has_valid);
    switch (type) {
        case PipeImplType::SimpleNoHandshakeNoBuffer: return "Pipe";
        case PipeImplType::SimpleValidNoBuffer: return "PipeV";
        case PipeImplType::SimpleHandshakeNoBuffer: return "PipeH";
        case PipeImplType::SimpleHandshakeBuffer: return "PipeHB";
    }
    return "PipeMHB";
}

vector<string> _genUnpackMultilineNoNext(const string &s) {
    vector<string> out_lines;
    size_t pos = 0;
    size_t n = s.size();
    while (pos < n) {
        size_t next_pos = s.find('\n', pos);
        if (next_pos == string::npos) {
            out_lines.push_back(s.substr(pos));
            break;
        } else {
            out_lines.push_back(s.substr(pos, next_pos - pos));
            pos = next_pos + 1;
        }
    }
    return out_lines;
}

string genCurrentTimeString() {
    std::chrono::system_clock::time_point now = std::chrono::system_clock::now();
    std::time_t tt = std::chrono::system_clock::to_time_t(now);
    std::tm* ptm = std::localtime(&tt);
    std::ostringstream oss;
    oss << std::put_time(ptm, "%Y-%m-%d %H:%M:%S");
    return oss.str();
}

vector<string> genHeaderPrelude() {
    static const vector<string> code_header_prelude = {
        "// This header file is generated by VulSim SimGen tool.\n",
        "// Do not modify this file directly.\n",
    };
    vector<string> out = code_header_prelude;
    out.push_back("// Generated on: " + genCurrentTimeString() + "\n");
    out.push_back("\n");
    out.push_back("#pragma once\n");
    out.push_back("\n");
    return out;
}

string replaceLog2CeilChar(const ConfigValue &v) {
    // replace @ with log2ceil function call
    if (v.find('@') == string::npos) {
        return v; // no '@' found, return original
    }
    string out;
    size_t n = v.size();
    size_t i = 0;
    while (i < n) {
        if (v[i] != '@') {
            out.push_back(v[i]);
            ++i;
            continue;
        }

        // found '@'
        size_t k = i + 1;
        // skip spaces immediately after '@'
        while (k < n && std::isspace(static_cast<unsigned char>(v[k]))) ++k;

        // if nothing follows, replace with an empty-call
        if (k >= n) {
            out += Log2CeilFunctionName + "()";
            i = n;
            break;
        }

        // if next is '(', reuse it as function call bracket
        if (v[k] == '(') {
            out += Log2CeilFunctionName; // keep the original '(' in next iterations
            i = k; // continue processing from the '('
            continue;
        }

        // identifier: [A-Za-z_][A-Za-z0-9_]*
        if (std::isalpha(static_cast<unsigned char>(v[k])) || v[k] == '_') {
            size_t t = k + 1;
            while (t < n && (std::isalnum(static_cast<unsigned char>(v[t])) || v[t] == '_')) ++t;
            out += Log2CeilFunctionName + "(" + v.substr(k, t - k) + ")";
            i = t;
            continue;
        }

        // number literal: decimal or hex (0x...)
        if (std::isdigit(static_cast<unsigned char>(v[k]))) {
            size_t t = k;
            if (t + 1 < n && v[t] == '0' && (v[t+1] == 'x' || v[t+1] == 'X')) {
                t += 2;
                while (t < n && std::isxdigit(static_cast<unsigned char>(v[t]))) ++t;
            } else {
                while (t < n && std::isdigit(static_cast<unsigned char>(v[t]))) ++t;
            }
            out += Log2CeilFunctionName + "(" + v.substr(k, t - k) + ")";
            i = t;
            continue;
        }

        // fallback: just insert function name and continue after spaces
        out += Log2CeilFunctionName;
        i = k;
    }

    return out;
}

vector<string> genCppHeaderPrelude() {
    static const vector<string> code_cpp_header_prelude = {
        "// This source file is generated by VulSim SimGen tool.\n",
        "// Do not modify this file directly.\n",
    };
    vector<string> out = code_cpp_header_prelude;
    out.push_back("// Generated on: " + genCurrentTimeString() + "\n");
    out.push_back("\n");
    return out;
}

ErrorMsg genConfigHeaderCode(const VulConfigLib &config_lib, vector<string> &out_lines) {
    out_lines = genHeaderPrelude();

    out_lines.push_back("#include \"common.h\"\n");
    out_lines.push_back("\n");
    out_lines.push_back("// Configuration Items\n");
    out_lines.push_back("\n");

    ErrorMsg err;
    vector<ConfigName> sorted_items;
    err = config_lib.getAllConfigItemsTopoSort(sorted_items);
    if (!err.empty()) {
        return err;
    }

    for (const auto &item_name : sorted_items) {
        VulConfigItem item;
        err = config_lib.getConfigItem(item_name, item);
        if (!err.empty()) {
            return err;
        }
        // generate comment per line
        for (const string &line : _genUnpackMultilineNoNext(item.comment)) {
            out_lines.push_back("// " + line + "\n");
        }
        // generate code line
        string line;
        line += "constexpr int64_t ";
        line += item.name;
        line += " = ";
        line += replaceLog2CeilChar(item.value);
        line += ";\n";
        out_lines.push_back(line);
        out_lines.push_back("\n");
    }

    return string();
}

void _genBundleContent(const VulBundleItem &item, vector<string> &out_lines) {
    const BundleName &bundle_name = item.name;
    // generate comment per line
    for (const string &line : _genUnpackMultilineNoNext(item.comment)) {
        out_lines.push_back("// " + line + "\n");
    }
    out_lines.push_back("\n");

    auto genMemberTypeStr = [&](const VulBundleMember &member) -> string {
        string type_str;
        string base_type = member.type;
        if (!member.uint_length.empty()) {
            base_type = UIntClassName + "<" + replaceLog2CeilChar(member.uint_length) + ">";
        }
        if (!member.dims.empty()) {
            for (const auto &dim : member.dims) {
                type_str += "std::array<";
            }
            type_str += base_type;
            for (uint32_t i = member.dims.size(); i > 0; i--) {
                type_str += ", " + replaceLog2CeilChar(member.dims[i-1]) + ">";
            }
        } else {
            type_str = base_type;
        }
        return type_str;
    };

    // generate code line
    // for alias bundle, generate a typedef
    if (item.is_alias) {
        if (!item.members.empty()) {
            string alias_target = genMemberTypeStr(item.members[0]);
            out_lines.push_back("typedef " + alias_target + " " + bundle_name + ";\n");
        }
    }
    // for enum bundle, generate enum class
    else if (!item.enum_members.empty()) {
        out_lines.push_back("enum class " + bundle_name + " {\n");
        for (const auto &em : item.enum_members) {
            string member_str = "    " + em.name;
            if (!em.value.empty()) {
                member_str += " = " + replaceLog2CeilChar(em.value);
            }
            member_str += ",";
            if (!em.comment.empty()) {
                member_str += " // " + em.comment;
            }
            out_lines.push_back(member_str + "\n");
        }
        out_lines.push_back("};\n");
    }
    // otherwise, generate typedef struct
    else {
        out_lines.push_back("typedef struct __" + bundle_name + "__ {\n");
        for (const auto &member : item.members) {
            string type_str = genMemberTypeStr(member);
            string member_str = "    " + type_str + " " + member.name;
            if (!member.value.empty() && (isBasicVulType(member.type) || !member.uint_length.empty())) {
                member_str += " = " + replaceLog2CeilChar(member.value);
            }
            member_str += ";";
            if (!member.comment.empty()) {
                member_str += " // " + member.comment;
            }
            out_lines.push_back(member_str + "\n");
        }
        out_lines.push_back("} " + bundle_name + ";\n");
    }

}

/**
 * @brief Generate bundle.h C++ header code for bundle definitions.
 * @param bundle_lib The VulBundleLib instance containing bundle definitions.
 * @param out_lines Output vector of strings to hold the generated header code lines. With \\n in each line.
 * @return An ErrorMsg indicating failure, empty if success.
 */
ErrorMsg genBundleHeaderCode(const VulBundleLib &bundle_lib, vector<string> &out_lines) {
    out_lines = genHeaderPrelude();

    out_lines.push_back("#include \"common.h\"\n");
    out_lines.push_back("#include \"config.h\"\n");
    out_lines.push_back("\n");
    out_lines.push_back("// Bundle Definitions\n");
    out_lines.push_back("\n");

    ErrorMsg err;
    vector<BundleName> sorted_bundles;
    err = bundle_lib.getAllBundlesTopoSort(sorted_bundles);
    if (!err.empty()) {
        return err;
    }

    for (const auto &bundle_name : sorted_bundles) {
        VulBundleItem item;
        unordered_set<BundleTag> tags;
        err = bundle_lib.getBundleDefinition(bundle_name, item, tags);
        if (!err.empty()) {
            return err;
        }
        // surround with ifndef guard when tagged
        bool is_not_default_tag = !(tags.size() == 1 && tags.count(bundle_lib.DefaultTag) == 1);
        string def_gaurd = "_BUNDLE_" + bundle_name + "_DEFINED_";
        if (is_not_default_tag) {
            for (const auto &tag : tags) {
                out_lines.push_back("#ifndef " + def_gaurd + "\n");
                out_lines.push_back("#define " + def_gaurd + " 1\n");
            }
        }

        _genBundleContent(item, out_lines);

        if (is_not_default_tag) {
            out_lines.push_back("#endif // " + def_gaurd + "\n");
        }
        out_lines.push_back("\n");
    }

    return string();
}

inline string _genReqServFuncReturnType(const VulReqServ &item) {
    return (item.has_handshake ? "bool" : "void");
}

inline string _genReqServFuncArgsTypes(const VulReqServ &item) {
    string args_str;
    for (const auto &arg : item.args) {
        if (!args_str.empty()) {
            args_str += ", ";
        }
        if (isBasicVulType(arg.type)) {
            args_str += "const " + arg.type;
        } else {
            args_str += "const " + arg.type + " &";
        }
    }
    for (const auto &ret : item.rets) {
        if (!args_str.empty()) {
            args_str += ", ";
        }
        args_str += ret.type + " *";
    }
    return args_str;
}

inline string _genReqServFuncArgsNames(const VulReqServ &item) {
    string args_str;
    for (const auto &arg : item.args) {
        if (!args_str.empty()) {
            args_str += ", ";
        }
        args_str += arg.name;
    }
    for (const auto &ret : item.rets) {
        if (!args_str.empty()) {
            args_str += ", ";
        }
        args_str += ret.name;
    }
    return args_str;
}

inline string _genReqServFuncArgsList(const VulReqServ &item) {
    string args_str;
    for (const auto &arg : item.args) {
        if (!args_str.empty()) {
            args_str += ", ";
        }
        if (isBasicVulType(arg.type)) {
            args_str += "const " + arg.type + " " + arg.name;
        } else {
            args_str += "const " + arg.type + " & " + arg.name;
        }
    }
    for (const auto &ret : item.rets) {
        if (!args_str.empty()) {
            args_str += ", ";
        }
        args_str += ret.type + " * " + ret.name;
    }
    return args_str;
}

/**
 * @brief Generate module.hpp C++ header code for a module definition.
 * @param module The VulModule instance containing the module definition.
 * @param out_lines Output vector of strings to hold the generated header code lines. With \\n in each line.
 * @return An ErrorMsg indicating failure, empty if success.
 */
ErrorMsg genModuleCodeHpp(const VulModule &module, vector<string> &out_lines, shared_ptr<VulModuleLib> modulelib) {

    vector<string> constructor_param_field;
    vector<string> tick_field;
    vector<string> apply_tick_field;
    vector<string> stall_field;
    vector<string> service_field;
    vector<string> init_field;
    vector<string> member_field;
    vector<string> local_bundle_field;
    string constructor_list;

    const ModuleName &mod_name = module.name;

    // generate local bundles
    for (const auto &bundle_entry : module.local_bundles) {
        _genBundleContent(bundle_entry.second, local_bundle_field);
        local_bundle_field.push_back("\n");
    }

    // generate request declarations
    for (const auto &req_entry : module.requests) {
        const VulReqServ &req = req_entry.second;
        string rettype = _genReqServFuncReturnType(req);
        string argtypes = _genReqServFuncArgsTypes(req);
        string argnames = _genReqServFuncArgsNames(req);
        string arglists = _genReqServFuncArgsList(req);
        if (!argtypes.empty()) {
            argtypes = ", " + argtypes;
        }
        constructor_param_field.push_back(CodeTab + rettype + " (*" + req_entry.first + ")(void *" + argtypes + ");\n");
        for (const string &line : _genUnpackMultilineNoNext(req.comment)) {
            member_field.push_back("// " + line + "\n");
        }
        member_field.push_back("FORCE_INLINE " + rettype + " " + req_entry.first + "(" + arglists + ") {\n");
        string return_prefix = (rettype == "void" ? "" : "return ");
        member_field.push_back(CodeTab + return_prefix + "__params." + req_entry.first + "(__params.__parent_module" + (argnames.empty() ? "" : ", " + argnames) + ");\n");
        member_field.push_back("}\n");
        member_field.push_back("\n");
    }

    // generate service declarations
    for (const auto &serv_entry : module.services) {
        const VulReqServ &serv = serv_entry.second;
        string rettype = _genReqServFuncReturnType(serv);
        string argnames = _genReqServFuncArgsNames(serv);
        string arglists = _genReqServFuncArgsList(serv);
        for (const string &line : _genUnpackMultilineNoNext(serv.comment)) {
            service_field.push_back("// " + line + "\n");
        }
        service_field.push_back("FORCE_INLINE " + rettype + " " + serv_entry.first + "(" + arglists + ") {\n");

        string return_prefix = (rettype == "void" ? "" : "return ");
        // find connection from this service
        // assume that invalid connections are already checked in earlier stages
        auto iter = module.req_connections.find(module.TopInterface);
        if (iter != module.req_connections.end()) {
            for (const auto &conn : iter->second) {
                if (conn.req_name == serv_entry.first) {
                    service_field.push_back(CodeTab + return_prefix + "__instptr_" + conn.serv_instance + "->" + conn.serv_name + "(" + argnames + ");\n");
                }
            }
        }
        // find user-defined service body if any
        auto user_serv_iter = module.serv_codelines.find(serv_entry.first);
        if (user_serv_iter != module.serv_codelines.end()) {
            for (const auto &line : user_serv_iter->second) {
                service_field.push_back(line);
            }
        }
        service_field.push_back("}\n");
        service_field.push_back("\n");
    }

    // generate pipe inputs
    for (const auto &pipe_entry : module.pipe_inputs) {
        const VulPipePort &pipe = pipe_entry.second;
        constructor_param_field.push_back(CodeTab + "PipePopPort<" + pipe.type + "> * " + pipe_entry.first + ";\n");
        for (const string &line : _genUnpackMultilineNoNext(pipe.comment)) {
            member_field.push_back("// " + line + "\n");
        }
        member_field.push_back("FORCE_INLINE bool " + pipe_entry.first + "_can_pop() {\n");
        member_field.push_back(CodeTab + "return __params." + pipe_entry.first + "->can_pop();\n");
        member_field.push_back("}\n");
        for (const string &line : _genUnpackMultilineNoNext(pipe.comment)) {
            member_field.push_back("// " + line + "\n");
        }
        member_field.push_back("FORCE_INLINE void " + pipe_entry.first + "_pop(" + pipe.type + " * data) {\n");
        member_field.push_back(CodeTab + "__params." + pipe_entry.first + "->pop(data);\n");
        member_field.push_back("}\n");
        for (const string &line : _genUnpackMultilineNoNext(pipe.comment)) {
            member_field.push_back("// " + line + "\n");
        }
        member_field.push_back("FORCE_INLINE void " + pipe_entry.first + "_top(" + pipe.type + " * data) {\n");
        member_field.push_back(CodeTab + "__params." + pipe_entry.first + "->top(data);\n");
        member_field.push_back("}\n");
    }

    // generate pipe outputs
    for (const auto &pipe_entry : module.pipe_outputs) {
        const VulPipePort &pipe = pipe_entry.second;
        constructor_param_field.push_back(CodeTab + "PipePushPort<" + pipe.type + "> * " + pipe_entry.first + ";");
        for (const string &line : _genUnpackMultilineNoNext(pipe.comment)) {
            member_field.push_back("// " + line + "\n");
        }
        member_field.push_back("FORCE_INLINE bool " + pipe_entry.first + "_can_push() {\n");
        member_field.push_back(CodeTab + "return __params." + pipe_entry.first + "->can_push();\n");
        member_field.push_back("}\n");
        for (const string &line : _genUnpackMultilineNoNext(pipe.comment)) {
            member_field.push_back("// " + line + "\n");
        }
        member_field.push_back("FORCE_INLINE void " + pipe_entry.first + "_push(const " + pipe.type + " & data) {\n");
        member_field.push_back(CodeTab + "__params." + pipe_entry.first + "->push(data);\n");
        member_field.push_back("}\n");
    }

    vector<InstanceName> tick_update_seq;
    {
        unordered_set<InstanceName> all_user_tick_instances;
        unordered_set<InstanceName> all_tick_fields;
        unordered_map<InstanceName, unordered_set<InstanceName>> tick_field_deps;
        for (const auto &entry: module.instances) {
            all_tick_fields.insert(entry.first);
            tick_field_deps[entry.first] = unordered_set<InstanceName>();
        }
        for (const auto &entry : module.user_tick_codeblocks) {
            all_user_tick_instances.insert(entry.first);
            all_tick_fields.insert(entry.first);
            tick_field_deps[entry.first] = unordered_set<InstanceName>();
        }

        for (const auto &conn : module.stalled_connections) {
            if (conn.former_instance == module.TopInterface) {
                continue;
            }
            if (conn.latter_instance == module.TopInterface) {
                tick_field_deps[conn.former_instance].insert(all_user_tick_instances.begin(), all_user_tick_instances.end());
            } else {
                tick_field_deps[conn.former_instance].insert(conn.latter_instance);
            }
        }
        for (const auto &conn : module.update_constraints) {
            if (conn.former_instance == module.TopInterface) {
                for (const auto &entry : module.user_tick_codeblocks) {
                    tick_field_deps[entry.first].insert(conn.latter_instance);
                }
            } else if (conn.latter_instance == module.TopInterface) {
                for (const auto &entry : module.user_tick_codeblocks) {
                    tick_field_deps[conn.former_instance].insert(entry.first);
                }
            } else {
                tick_field_deps[conn.former_instance].insert(conn.latter_instance);
            }
        }
        vector<InstanceName> looped_instances;
        auto sorted_result = topologicalSort(all_tick_fields, tick_field_deps, looped_instances);
        if (sorted_result == nullptr) {
            string loop_nodes_str;
            for (const auto &node : looped_instances) {
                if (!loop_nodes_str.empty()) {
                    loop_nodes_str += ", ";
                }
                loop_nodes_str += "'" + node + "'";
            }
            return EStr(ErrReqConnCheck, "Tick/Update sequence loop detected among instances: " + loop_nodes_str);
        }
        tick_update_seq.swap(*sorted_result);
    }
    // generate user tick codeblocks
    for (const auto &inst_name : tick_update_seq) {
        auto user_tick_iter = module.user_tick_codeblocks.find(inst_name);
        if (user_tick_iter != module.user_tick_codeblocks.end()) {
            const VulTickCodeBlock &codeblock = user_tick_iter->second;
            for (const string &line : _genUnpackMultilineNoNext(codeblock.comment)) {
                member_field.push_back("// " + line + "\n");
            }
            member_field.push_back("FORCE_INLINE void __tick_codeblock_" + inst_name + "() {\n");
            for (const auto &line : codeblock.codelines) {
                member_field.push_back(line);
            }
            member_field.push_back("}\n");
            member_field.push_back("\n");
            tick_field.push_back(CodeTab + "__tick_codeblock_" + inst_name + "();\n");
        } else {
            // tick function call for child module instance
            auto inst_iter = module.instances.find(inst_name);
            if (inst_iter != module.instances.end()) {
                tick_field.push_back(CodeTab + "__instptr_" + inst_name + "->" + TickFunctionName + "();\n");
            }
        }
    }
    // generate child req codelines implementations
    for (const auto &reqcl_entry : module.req_codelines) {
        const InstanceName &inst_name = reqcl_entry.first;
        for (const auto &req_entry : reqcl_entry.second) {
            const ReqServName &req_name = req_entry.first;
            auto &childmod_ptr = modulelib->modules.at(module.instances.at(inst_name).module_name);
            auto &childreq = childmod_ptr->requests.at(req_name);
            string rettype = _genReqServFuncReturnType(childreq);
            string arglists = _genReqServFuncArgsList(childreq);
            member_field.push_back("FORCE_INLINE " + rettype + " __childreq_" + inst_name + "_" + req_name + "(" + arglists + ") {\n");
            for (const auto &line : req_entry.second) {
                member_field.push_back(line);
            }
            member_field.push_back("}\n");
            member_field.push_back("\n");
        }
    }

    auto _genStoTypeNormal = [&](const VulStorage &sto) -> string {
        string type_str;
        string base_type = sto.type;
        if (!sto.uint_length.empty()) {
            base_type = UIntClassName + "<" + replaceLog2CeilChar(sto.uint_length) + ">";
        }
        if (!sto.dims.empty()) {
            for (const auto &dim : sto.dims) {
                type_str += "std::array<";
            }
            type_str += base_type;
            for (uint32_t i = sto.dims.size(); i > 0; i--) {
                type_str += ", " + replaceLog2CeilChar(sto.dims[i-1]) + ">";
            }
        } else {
            type_str = base_type;
        }
        return type_str;
    };
    auto _genStoTypeNext = [&](const VulStorage &sto) -> string {
        string type_str;
        string base_type = sto.type;
        if (!sto.uint_length.empty()) {
            base_type = UIntClassName + "<" + replaceLog2CeilChar(sto.uint_length) + ">";
        }
        if (!sto.dims.empty()) {
            type_str += StorageNextArrayClassName + "<" + base_type;
            for (const auto &dim : sto.dims) {
                type_str += "," + replaceLog2CeilChar(dim);
            }
            type_str += ">";
        } else {
            type_str = StorageNextClassName + "<" + base_type + ">";
        }
        return type_str;
    };
    // generate storage members
    for (const auto &sto_entry : module.storages) {
        const VulStorage &sto = sto_entry.second;
        for (const string &line : _genUnpackMultilineNoNext(sto.comment)) {
            member_field.push_back("// " + line + "\n");
        }
        string line = _genStoTypeNormal(sto) + " " + sto_entry.first;
        if (!sto.value.empty()) {
            line += " = " + replaceLog2CeilChar(sto.value);
        }
        line += ";\n";
        member_field.push_back(line);
        member_field.push_back("\n");
    }
    // generate next-state storage members
    for (const auto &sto_entry : module.storagenexts) {
        const VulStorage &sto = sto_entry.second;
        for (const string &line : _genUnpackMultilineNoNext(sto.comment)) {
            member_field.push_back("// " + line + "\n");
        }
        string line = _genStoTypeNext(sto) + " " + sto_entry.first + ";\n";
        member_field.push_back(line);
        member_field.push_back("\n");
        apply_tick_field.push_back(CodeTab + sto_entry.first + "." + ApplyTickFunctionName + "();\n");
    }
    // generate tmp storage members
    for (const auto &sto_entry : module.storagetmp) {
        const VulStorage &sto = sto_entry.second;
        for (const string &line : _genUnpackMultilineNoNext(sto.comment)) {
            member_field.push_back("// " + line + "\n");
        }
        string statement = sto_entry.first + " = " + replaceLog2CeilChar(sto.value) + ";";
        member_field.push_back(_genStoTypeNormal(sto) + " " + statement);
        member_field.push_back("\n");
        apply_tick_field.push_back(CodeTab + statement);
    }

    // generate pipe instance
    for (const auto &pipe_entry : module.pipe_instances) {
        const VulPipe &pipe = pipe_entry.second;
        string pipe_class_raw = PipeClassName;
        string pipe_class = pipe_class_raw + "<" +
            pipe.type + ", " +
            (pipe.input_size) + ", " +
            (pipe.output_size) + ", " +
            (pipe.buffer_size) + ", " +
            (pipe.latency) + ">";
        string pipe_instptr_name = "__instptr_" + pipe_entry.first;
        member_field.push_back("std::unique_ptr<" + pipe_class + "> " + pipe_instptr_name + ";\n");

        for (const string &line : _genUnpackMultilineNoNext(pipe.comment)) {
            member_field.push_back("// " + line + "\n");
        }
        member_field.push_back("FORCE_INLINE bool " + pipe_entry.first + "_can_pop() {\n");
        member_field.push_back(CodeTab + "return " + pipe_instptr_name + "->get_pop_port()->can_pop();\n");
        member_field.push_back("}\n");
        
        for (const string &line : _genUnpackMultilineNoNext(pipe.comment)) {
            member_field.push_back("// " + line + "\n");
        }
        member_field.push_back("FORCE_INLINE void " + pipe_entry.first + "_pop(" + pipe.type + " * data) {\n");
        member_field.push_back(CodeTab + "return " + pipe_instptr_name + "->get_pop_port()->pop(data);\n");
        member_field.push_back("}\n");

        for (const string &line : _genUnpackMultilineNoNext(pipe.comment)) {
            member_field.push_back("// " + line + "\n");
        }
        member_field.push_back("FORCE_INLINE void " + pipe_entry.first + "_top(" + pipe.type + " * data) {\n");
        member_field.push_back(CodeTab + "return " + pipe_instptr_name + "->get_pop_port()->top(data);\n");
        member_field.push_back("}\n");

        for (const string &line : _genUnpackMultilineNoNext(pipe.comment)) {
            member_field.push_back("// " + line + "\n");
        }
        member_field.push_back("FORCE_INLINE bool " + pipe_entry.first + "_can_push() {\n");
        member_field.push_back(CodeTab + "return " + pipe_instptr_name + "->get_push_port()->can_push();\n");
        member_field.push_back("}\n");
        
        for (const string &line : _genUnpackMultilineNoNext(pipe.comment)) {
            member_field.push_back("// " + line + "\n");
        }
        member_field.push_back("FORCE_INLINE void " + pipe_entry.first + "_push(const " + pipe.type + " & data) {\n");
        member_field.push_back(CodeTab + "return " + pipe_instptr_name + "->get_push_port()->push(data);\n");
        member_field.push_back("}\n");

        init_field.push_back(CodeTab + pipe_instptr_name + " = std::make_unique<" + pipe_class + ">();\n");
    }

    // generate stall field
    for (const auto &conn : module.stalled_connections) {
        if (conn.former_instance != VulModule::TopInterface) {
            continue;
        }
        stall_field.push_back(CodeTab + "__instptr_" + conn.latter_instance + "->stall();\n");
    }

    // generate instances
    for (const auto &inst_entry : module.instances) {
        const InstanceName &inst_name = inst_entry.first;
        const VulInstance &inst = inst_entry.second;
        const ModuleName &child_mod = inst.module_name;
        auto &childmod_ptr = modulelib->modules.at(child_mod);
        string child_instptr_name = "__instptr_" + inst_entry.first;
        string child_class_name = child_mod;
        if (!childmod_ptr->local_configs.empty()) {
            child_class_name += "<";
            bool first_cfg = true;
            for (const auto &cfg_entry : childmod_ptr->local_configs) {
                if (!first_cfg) {
                    child_class_name += ", ";
                }
                first_cfg = false;
                auto iter = inst.local_config_overrides.find(cfg_entry.first);
                if (iter == inst.local_config_overrides.end()) {
                    child_class_name += replaceLog2CeilChar(cfg_entry.second.value);
                } else {
                    child_class_name += replaceLog2CeilChar(iter->second);
                }
            }
            child_class_name += ">";
        }

        member_field.push_back("std::unique_ptr<" + child_class_name + "> " + child_instptr_name + ";\n");

        for (const auto &serv_entry : childmod_ptr->services) {
            const VulReqServ &serv = serv_entry.second;
            string rettype = _genReqServFuncReturnType(serv);
            string arglists = _genReqServFuncArgsList(serv);
            string argname = _genReqServFuncArgsNames(serv);
            for (const string &line : _genUnpackMultilineNoNext(serv.comment)) {
                member_field.push_back("// " + line + "\n");
            }
            member_field.push_back("FORCE_INLINE " + rettype + " " + inst_entry.first + "_" + serv_entry.first + "(" + arglists + ") {\n");
            string return_prefix = (rettype == "void" ? "" : "return ");
            member_field.push_back(CodeTab + return_prefix + child_instptr_name + "->" + serv_entry.first + "(" + argname + ");\n");
            member_field.push_back("}\n");
        }

        string parent_ptr_cast = "static_cast<" + mod_name + "*>(__parent_module)";

        for (const auto &req_entry : childmod_ptr->requests) {
            const VulReqServ &req = req_entry.second;
            string rettype = _genReqServFuncReturnType(req);
            string arglist = _genReqServFuncArgsList(req);
            string argname = _genReqServFuncArgsNames(req);

            string wrapper_arglist = "void * __parent_module";
            if (!arglist.empty()) {
                wrapper_arglist += ", " + arglist;
            }
            member_field.push_back("static " + rettype + " __childreq_" + inst_entry.first + "_" + req_entry.first + "_wrapper(" + wrapper_arglist + ") {\n");
            string return_prefix = (rettype == "void" ? "" : "return ");
            // connection to module request
            // connection to child module service
            auto iter = module.req_connections.find(inst_name);
            if (iter != module.req_connections.end()) [[likely]] {
                for (const auto &conn : iter->second) {
                    if (conn.req_name == req_entry.first) {
                        if (conn.serv_instance == VulModule::TopInterface) {
                            member_field.push_back(CodeTab + return_prefix + parent_ptr_cast + "->" + conn.serv_name + "(" + argname + ");\n");
                        } else {
                            member_field.push_back(CodeTab + return_prefix + parent_ptr_cast + "->" + conn.serv_instance + "_" + conn.serv_name + "(" + argname + ");\n");
                        }
                    }
                }
            }
            // implement by user-defined code
            auto user_req_iter = module.req_codelines.find(inst_name);
            if (user_req_iter != module.req_codelines.end()) {
                auto req_codeblock_iter = user_req_iter->second.find(req_entry.first);
                if (req_codeblock_iter != user_req_iter->second.end()) {
                    member_field.push_back(CodeTab + return_prefix + parent_ptr_cast + "->__childreq_" + inst_name + "_" + req_entry.first + "(" + argname + ");\n");
                }
            }
        }

        member_field.push_back("static void __childstall_" + inst_name + "_wrapper(void * __parent_module) {\n");
        for (const auto & stall_conn : module.stalled_connections) {
            if (stall_conn.former_instance != inst_name) {
                continue;
            }
            if (stall_conn.latter_instance == VulModule::TopInterface) {
                member_field.push_back(CodeTab + parent_ptr_cast + "->__stall_propagate_out();\n");
            } else {
                member_field.push_back(CodeTab + parent_ptr_cast + "->__instptr_" + stall_conn.latter_instance + "->stall();\n");
            }
        }
        member_field.push_back("}\n");
        for (const auto &lcbund : childmod_ptr->local_bundles) {
            member_field.push_back("using " + inst_name + "_" + lcbund.first + " = " + child_class_name + "::" + lcbund.first + ";\n");
        }

        member_field.push_back("\n");

        // constructor init
        init_field.push_back(CodeTab + "{\n");
        const string indent = CodeTab + CodeTab;

        init_field.push_back(indent + child_class_name + "::ConstructorParams cparams;\n");
        init_field.push_back(indent + "cparams.__parent_module = this;\n");
        init_field.push_back(indent + "cparams.__instance_name = __params.__instance_name + \"::" + inst_name + "\";\n");
        init_field.push_back(indent + "cparams.__stall = &__childstall_" + inst_name + "_wrapper;\n");

        for (const auto &req_entry : childmod_ptr->requests) {
            string wrapper_name = "__childreq_" + inst_name + "_" + req_entry.first + "_wrapper";
            init_field.push_back(indent + "cparams." + req_entry.first + " = &" + wrapper_name + ";\n");
        }
        for (const auto &pipein_entry : childmod_ptr->pipe_inputs) {
            for (const auto &conn : module.mod_pipe_connections.at(inst_name)) {
                if (conn.instance_pipe_port != pipein_entry.first) {
                    continue;
                }
                if (conn.pipe_instance == VulModule::TopInterface) {
                    init_field.push_back(indent + "cparams." + pipein_entry.first + " = __params." + conn.top_pipe_port + ";\n");
                } else {
                    init_field.push_back(indent + "cparams." + pipein_entry.first + " = __pipeinstptr_" + conn.pipe_instance + "->get_pop_port();\n");
                }
            }
        }
        for (const auto &pipeout_entry : childmod_ptr->pipe_outputs) {
            for (const auto &conn : module.mod_pipe_connections.at(inst_name)) {
                if (conn.instance_pipe_port != pipeout_entry.first) {
                    continue;
                }
                if (conn.pipe_instance == VulModule::TopInterface) {
                    init_field.push_back(indent + "cparams." + pipeout_entry.first + " = __params." + conn.top_pipe_port + ";\n");
                } else {
                    init_field.push_back(indent + "cparams." + pipeout_entry.first + " = __pipeinstptr_" + conn.pipe_instance + "->get_push_port();\n");
                }
            }
        }
        init_field.push_back(indent + child_instptr_name + " = std::make_unique<" + child_class_name + ">(cparams);\n");
        init_field.push_back(CodeTab + "}\n");

        // tick function has been generated above in tick_update_seq
        apply_tick_field.push_back(CodeTab + child_instptr_name + "->" + ApplyTickFunctionName + "();\n");
    }

    // preparation done, start generating code lines

    out_lines = genHeaderPrelude();
    out_lines.push_back("#include \"common.h\"\n");
    out_lines.push_back("#include \"config.h\"\n");
    out_lines.push_back("#include \"bundle.h\"\n");
    out_lines.push_back("#include \"vullib.h\"\n");
    out_lines.push_back("\n");

    // include child module headers
    unordered_set<ModuleName> included_modules;
    for (const auto &inst_entry : module.instances) {
        const VulInstance &inst = inst_entry.second;
        if (included_modules.find(inst.module_name) == included_modules.end()) {
            out_lines.push_back("#include \"" + inst.module_name + ".hpp\"\n");
            included_modules.insert(inst.module_name);
        }
    }
    out_lines.push_back("\n");
    
    // begin class definition
    for (const string &line : _genUnpackMultilineNoNext(module.comment)) {
        out_lines.push_back("// " + line + "\n");
    }
    if (!module.local_configs.empty()) {
        string template_line = "";
        for (const auto &lc_entry : module.local_configs) {
            const VulLocalConfigItem &lc = lc_entry.second;
            if (!template_line.empty()) {
                template_line += ", ";
            }
            template_line += "int64_t " + lc.name;
        }
        if (!template_line.empty()) {
            out_lines.push_back("template <" + template_line + ">\n");
        }
    }
    out_lines.push_back("class " + mod_name + " {\n");
    out_lines.push_back("public:\n");
    out_lines.push_back("\n");

    // ConstructorParams struct
    out_lines.push_back("typedef struct __ConstructorParams__ {\n");
    out_lines.push_back(CodeTab + "void * __parent_module;\n");
    out_lines.push_back(CodeTab + "std::string __instance_name;\n");
    out_lines.push_back(CodeTab + "void (*__stall)(void *);\n");
    for (const auto &line : constructor_param_field) {
        out_lines.push_back(line);
    }
    out_lines.push_back("} ConstructorParams;\n");
    out_lines.push_back("\n");

    // Local Bundles
    for (const auto &line : local_bundle_field) {
        out_lines.push_back(line);
    }
    out_lines.push_back("\n");

    // Constructor
    out_lines.push_back("explicit " + mod_name + "(const ConstructorParams & __params) : \n");
    out_lines.push_back(CodeTab + CodeTab + "__params(__params)" + constructor_list + " {\n");
    out_lines.push_back(CodeTab + "__init();\n");
    out_lines.push_back("}\n");

    // Tick function
    out_lines.push_back("FORCE_INLINE void " + TickFunctionName + "() {\n");
    for (const auto &line : tick_field) {
        out_lines.push_back(line);
    }
    out_lines.push_back("}\n");
    out_lines.push_back("\n");

    // ApplyTick function
    out_lines.push_back("FORCE_INLINE void " + ApplyTickFunctionName + "() {\n");
    out_lines.push_back(CodeTab + "__is_stalled = false;\n");
    for (const auto &line : apply_tick_field) {
        out_lines.push_back(line);
    }
    out_lines.push_back("}\n");
    out_lines.push_back("\n");

    // Stall function
    out_lines.push_back("FORCE_INLINE void stall() {\n");
    for (const auto &line : stall_field) {
        out_lines.push_back(line);
    }
    out_lines.push_back(CodeTab + "__stall_propagate_out();\n");
    out_lines.push_back("}\n");
    out_lines.push_back("\n");

    // Service functions
    for (const auto &line : service_field) {
        out_lines.push_back(line);
    }

    // Protected members (Auto-generated members)
    out_lines.push_back("protected:\n");
    out_lines.push_back("\n");

    // Parameter instance
    out_lines.push_back("ConstructorParams __params;\n");
    out_lines.push_back("\n");

    // Init function
    out_lines.push_back("FORCE_INLINE void __init() {\n");
    for (const auto &line : init_field) {
        out_lines.push_back(line);
    }
    out_lines.push_back("}\n");
    out_lines.push_back("\n");

    // Stall members
    out_lines.push_back("bool __is_stalled = false;\n");
    out_lines.push_back("FORCE_INLINE bool is_stalled() const { return __is_stalled; }\n");
    out_lines.push_back("FORCE_INLINE void __stall_propagate_out() {\n");
    out_lines.push_back(CodeTab + "__is_stalled = true;\n");
    out_lines.push_back(CodeTab + "__params.__stall(__params.__parent_module);\n");
    out_lines.push_back("}\n");
    out_lines.push_back("\n");

    // Member fields
    for (const auto &line : member_field) {
        out_lines.push_back(line);
    }

    // Private members (User-defined members)
    out_lines.push_back("private:\n");
    out_lines.push_back("\n");

    for (const auto &line : module.user_header_field_codelines) {
        out_lines.push_back(line);
    }

    // Finish class definition
    out_lines.push_back("};\n");
    out_lines.push_back("\n");
    return "";
}


} // namespace simgen

